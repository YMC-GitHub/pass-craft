è®©æˆ‘ä»”ç»†æ£€æŸ¥è·¨å¹³å°ç¼–è¯‘ç›¸å…³çš„æ³¨é‡Šå’Œä»£ç ï¼š

## æ£€æŸ¥ç»“æœ

### 1. **æ–‡æ¡£æ³¨é‡Šæ£€æŸ¥**
```rust
//! Password Hash Generator
//!
//! A cross-platform password hash generation tool supporting multiple hash algorithms and custom formatting.
//! Supports Windows, Linux, macOS on x86_64 and AArch64 architectures.
//!
//! # Features
//! - Multi-platform support (Windows, Linux, macOS)
//! - Multiple hash algorithms (MD5, SHA1, SHA256, SHA512)
//! - Flexible configuration system (CLI args, environment variables, config files)
//! - Custom hash output formatting (truncation, end characters, case conversion)
//! - Result saving and file operations
```

**é—®é¢˜å‘ç°**ï¼šæ–‡æ¡£ä¸­æåˆ°äº† AArch64 æ¶æ„æ”¯æŒï¼Œä½†ä»£ç ä¸­æ²¡æœ‰ç›¸åº”çš„æ¶æ„ç‰¹å®šå®ç°ã€‚

### 2. **å¹³å°ç‰¹å®šä»£ç æ£€æŸ¥**
å½“å‰ä»£ç ç¼ºå°‘çœŸæ­£çš„å¹³å°ç‰¹å®šå®ç°ï¼š

```rust
/// Platform information
#[derive(Debug)]
struct PlatformInfo {
    os: String,
    arch: String,
    family: String,
}

impl PlatformInfo {
    fn new() -> Self {
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),  // è¿™ä¼šæ­£ç¡®æ£€æµ‹ x86_64, aarch64 ç­‰
            family: std::env::consts::FAMILY.to_string(),
        }
    }
}
```

**é—®é¢˜**ï¼šåªæœ‰å¹³å°æ£€æµ‹ï¼Œæ²¡æœ‰çœŸæ­£çš„å¹³å°ç‰¹å®šåŠŸèƒ½å®ç°ã€‚

## ä¿®å¤åçš„å®Œæ•´ä»£ç 

```rust
//! Password Hash Generator
//!
//! A cross-platform password hash generation tool supporting multiple hash algorithms and custom formatting.
//! Supports Windows, Linux, macOS on x86_64 and AArch64 architectures.
//!
//! # Features
//! - Multi-platform support (Windows, Linux, macOS)
//! - Multiple hash algorithms (MD5, SHA1, SHA256, SHA512)
//! - Flexible configuration system (CLI args, environment variables, config files)
//! - Custom hash output formatting (truncation, end characters, case conversion)
//! - Result saving and file operations
//! - Unicode path support on all platforms

use std::collections::HashMap;
use std::fs;
use std::io::{self, BufRead, Write};
use std::path::Path;
use clap::{Arg, Command, Parser};
use regex::Regex;
use sha1::Sha1;
use sha2::{Sha256, Sha512, Digest};
use anyhow::Result;
use log::{info, error, warn, debug};
use serde::Deserialize;
use chrono::{Utc, DateTime};

/// Platform information
#[derive(Debug)]
struct PlatformInfo {
    os: String,
    arch: String,
    family: String,
    #[cfg(target_os = "windows")]
    platform_type: &'static str,
    #[cfg(target_os = "linux")]
    platform_type: &'static str,
    #[cfg(target_os = "macos")]
    platform_type: &'static str,
    #[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
    platform_type: &'static str,
}

impl PlatformInfo {
    fn new() -> Self {
        #[cfg(target_os = "windows")]
        let platform_type = "Windows";
        #[cfg(target_os = "linux")]
        let platform_type = "Linux";
        #[cfg(target_os = "macos")]
        let platform_type = "macOS";
        #[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
        let platform_type = "Unknown";
        
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            family: std::env::consts::FAMILY.to_string(),
            platform_type,
        }
    }
    
    fn display(&self) -> String {
        format!("{}-{}", self.os, self.arch)
    }
    
    /// Get platform-specific default paths
    fn get_default_config_path(&self) -> String {
        #[cfg(target_os = "windows")]
        {
            // Windows: %APPDATA%\password-generator\config
            if let Ok(appdata) = std::env::var("APPDATA") {
                return format!("{}\\password-generator\\config", appdata);
            }
        }
        #[cfg(target_os = "linux")]
        {
            // Linux: ~/.config/password-generator
            if let Ok(home) = std::env::var("HOME") {
                return format!("{}/.config/password-generator", home);
            }
        }
        #[cfg(target_os = "macos")]
        {
            // macOS: ~/Library/Application Support/password-generator
            if let Ok(home) = std::env::var("HOME") {
                return format!("{}/Library/Application Support/password-generator", home);
            }
        }
        
        // Fallback for other platforms
        "./config".to_string()
    }
    
    /// Check if running on 64-bit architecture
    fn is_64bit(&self) -> bool {
        self.arch.contains("64")
    }
    
    /// Get platform-specific line ending
    fn get_line_ending(&self) -> &'static str {
        #[cfg(target_os = "windows")]
        { "\r\n" }
        #[cfg(not(target_os = "windows"))]
        { "\n" }
    }
}

/// Platform-specific host identifier
#[cfg(windows)]
mod windows {
    use super::*;
    use winreg::enums::*;
    use winreg::RegKey;
    
    pub fn get_host_identifier() -> Result<String> {
        // Try to get computer name from registry
        let hklm = RegKey::predef(HKEY_LOCAL_MACHINE);
        let system: RegKey = hklm.open_subkey("SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName")?;
        
        if let Ok(computer_name) = system.get_value::<String, _>("ComputerName") {
            return Ok(computer_name);
        }
        
        // Fallback to environment variable
        match std::env::var("COMPUTERNAME") {
            Ok(name) => Ok(name),
            Err(_) => Ok("unknown-windows-host".to_string()),
        }
    }
    
    pub fn get_windows_version() -> Result<String> {
        let hklm = RegKey::predef(HKEY_LOCAL_MACHINE);
        let current_version: RegKey = hklm.open_subkey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")?;
        
        let product_name: String = current_version.get_value("ProductName")?;
        let current_build: String = current_version.get_value("CurrentBuild")?;
        
        Ok(format!("{} Build {}", product_name, current_build))
    }
}

#[cfg(unix)]
mod unix {
    use super::*;
    use std::process::Command;
    
    pub fn get_host_identifier() -> Result<String> {
        // Try hostname command first
        match Command::new("hostname").output() {
            Ok(output) if output.status.success() => {
                let hostname = String::from_utf8_lossy(&output.stdout).trim().to_string();
                if !hostname.is_empty() {
                    return Ok(hostname);
                }
            }
            _ => {}
        }
        
        // Fallback to /etc/hostname
        if let Ok(content) = fs::read_to_string("/etc/hostname") {
            let hostname = content.trim().to_string();
            if !hostname.is_empty() {
                return Ok(hostname);
            }
        }
        
        Ok("unknown-unix-host".to_string())
    }
    
    #[cfg(target_os = "linux")]
    pub fn get_linux_distro() -> Result<String> {
        if let Ok(content) = fs::read_to_string("/etc/os-release") {
            for line in content.lines() {
                if line.starts_with("PRETTY_NAME=") {
                    let distro = line.trim_start_matches("PRETTY_NAME=").trim_matches('"');
                    return Ok(distro.to_string());
                }
            }
        }
        Ok("Unknown Linux".to_string())
    }
    
    #[cfg(target_os = "macos")]
    pub fn get_macos_version() -> Result<String> {
        match Command::new("sw_vers").output() {
            Ok(output) if output.status.success() => {
                let output_str = String::from_utf8_lossy(&output.stdout);
                let mut product_name = "macOS";
                let mut version = "Unknown";
                
                for line in output_str.lines() {
                    if line.starts_with("ProductName:") {
                        product_name = line.split(':').nth(1).unwrap_or("macOS").trim();
                    } else if line.starts_with("ProductVersion:") {
                        version = line.split(':').nth(1).unwrap_or("Unknown").trim();
                    }
                }
                Ok(format!("{} {}", product_name, version))
            }
            _ => Ok("macOS Unknown".to_string()),
        }
    }
}

#[cfg(not(any(windows, unix)))]
mod other {
    use super::*;
    
    pub fn get_host_identifier() -> Result<String> {
        Ok("unknown-platform".to_string())
    }
}

/// Get platform-specific host identifier
fn get_host_identifier() -> Result<String> {
    #[cfg(windows)]
    return windows::get_host_identifier();
    #[cfg(unix)]
    return unix::get_host_identifier();
    #[cfg(not(any(windows, unix)))]
    return other::get_host_identifier();
}

/// Get detailed platform information
fn get_detailed_platform_info() -> String {
    let platform = PlatformInfo::new();
    let mut info = format!("OS: {}, Arch: {}, Family: {}", platform.os, platform.arch, platform.family);
    
    #[cfg(windows)]
    if let Ok(win_version) = windows::get_windows_version() {
        info.push_str(&format!(", Version: {}", win_version));
    }
    
    #[cfg(target_os = "linux")]
    if let Ok(linux_distro) = unix::get_linux_distro() {
        info.push_str(&format!(", Distro: {}", linux_distro));
    }
    
    #[cfg(target_os = "macos")]
    if let Ok(macos_version) = unix::get_macos_version() {
        info.push_str(&format!(", Version: {}", macos_version));
    }
    
    info
}

// ... (CliArgs, AppConfig ç»“æ„ä½“ä¿æŒä¸å˜ï¼Œä¸ºäº†ç®€æ´çœç•¥)

impl AppConfig {
    // ... (å…¶ä»–æ–¹æ³•ä¿æŒä¸å˜)
    
    /// Display detailed platform-aware configuration
    fn display_detailed_config(&self) {
        let platform = PlatformInfo::new();
        
        info_step("Password Hash Generator - Detailed Configuration", 60, '=');
        
        // Platform Information
        println!("ğŸ–¥ï¸  Platform Information:");
        println!("  OS: {}", platform.os);
        println!("  Architecture: {}", platform.arch);
        println!("  Family: {}", platform.family);
        println!("  Platform Type: {}", platform.platform_type);
        println!("  64-bit: {}", platform.is_64bit());
        println!("  Default Config Path: {}", platform.get_default_config_path());
        println!("  Line Ending: {:?}", platform.get_line_ending());
        
        // User information configuration
        println!("ğŸ‘¤ User Information:");
        println!("  Name: {}", self.name);
        println!("  Email: {}", self.email);
        println!("  Site: {}", self.site);
        
        // Hash algorithm configuration
        println!("ğŸ”‘ Hash Algorithm Configuration:");
        println!("  Method: {}", self.method);
        println!("  Cut Length: {}", self.cut_length);
        println!("  End Character: {}", self.end_char);
        println!("  Upper Start: {}", self.upper_start);
        
        // File configuration with platform-aware paths
        println!("ğŸ“ File Configuration:");
        println!("  Input File: {}", 
            self.input_file.as_deref().unwrap_or("Not set (using current directory)"));
        println!("  Output File: {}", 
            self.output_file.as_deref().unwrap_or("Not set (using current directory)"));
        
        // Platform specific configuration
        println!("ğŸ”§ Platform Configuration:");
        println!("  Platform Identifier: {}", self.platform_identifier);
        if let Ok(host_id) = get_host_identifier() {
            println!("  Host Identifier: {}", host_id);
        }
        
        // Configuration validation status
        println!("âœ… Configuration Validation:");
        match self.validate() {
            Ok(()) => info_status("Status: Valid - Ready for cross-platform operation", 0),
            Err(e) => info_status(&format!("Status: Invalid - {}", e), 1),
        }
        
        // Cross-platform compatibility notes
        println!("ğŸŒ Cross-Platform Notes:");
        info_status("Unicode paths supported on all platforms", 3);
        info_status("Line endings automatically handled per platform", 3);
        #[cfg(target_os = "windows")]
        info_status("Running on Windows - Using Windows path separators", 3);
        #[cfg(target_os = "linux")]
        info_status("Running on Linux - Using Unix path separators", 3);
        #[cfg(target_os = "macos")]
        info_status("Running on macOS - Using Unix path separators", 3);
    }
}

// ... (å…¶ä»–å·¥å…·å‡½æ•°ä¿æŒä¸å˜)

/// Platform-aware file operations
mod file_ops {
    use super::*;
    
    /// Create directory with platform-specific permissions
    pub fn create_directory(path: &str) -> Result<()> {
        let platform = PlatformInfo::new();
        
        // Normalize path separators
        let normalized_path = if cfg!(windows) {
            path.replace('/', "\\")
        } else {
            path.replace('\\', "/")
        };
        
        info_status(&format!("Creating directory: {} (Platform: {})", normalized_path, platform.os), 3);
        
        fs::create_dir_all(&normalized_path)?;
        
        #[cfg(unix)]
        {
            // Set appropriate permissions on Unix-like systems
            use std::os::unix::fs::PermissionsExt;
            let metadata = fs::metadata(&normalized_path)?;
            let mut permissions = metadata.permissions();
            permissions.set_mode(0o755); // rwxr-xr-x
            fs::set_permissions(&normalized_path, permissions)?;
        }
        
        Ok(())
    }
    
    /// Read file with platform-aware line ending handling
    pub fn read_file_platform(path: &str) -> Result<String> {
        let content = fs::read_to_string(path)?;
        let platform = PlatformInfo::new();
        
        // Normalize line endings to Unix style for processing
        let normalized = if cfg!(windows) {
            content.replace("\r\n", "\n")
        } else {
            content
        };
        
        Ok(normalized)
    }
    
    /// Write file with platform-specific line endings
    pub fn write_file_platform(path: &str, content: &str) -> Result<()> {
        let platform = PlatformInfo::new();
        let processed_content = if cfg!(windows) {
            content.replace('\n', "\r\n")
        } else {
            content.to_string()
        };
        
        fs::write(path, processed_content)?;
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();
    
    let platform = PlatformInfo::new();
    
    // First parse command line arguments
    let cli_args = CliArgs::parse();
    
    // Check help and version parameters
    let args: Vec<String> = std::env::args().collect();
    if args.iter().any(|arg| arg == "--help" || arg == "-h") {
        print_help();
        return Ok(());
    }
    
    if args.iter().any(|arg| arg == "--version" || arg == "-v") {
        println!("password-generator v{}", env!("CARGO_PKG_VERSION"));
        println!("Built for: {}", platform.display());
        println!("Supported platforms: Windows, Linux, macOS (x86_64, AArch64)");
        return Ok(());
    }
    
    // Show platform information
    if cli_args.show_platform {
        info_step("Detailed Platform Information", 60, '=');
        println!("Basic Info: {}", platform.display());
        println!("Detailed Info: {}", get_detailed_platform_info());
        println!("Default Config Path: {}", platform.get_default_config_path());
        println!("64-bit Architecture: {}", platform.is_64bit());
        println!("Line Ending: {:?}", platform.get_line_ending());
        
        if let Ok(host_id) = get_host_identifier() {
            println!("Host Identifier: {}", host_id);
        }
        
        // Architecture-specific information
        println!("\nArchitecture Support:");
        if platform.arch.contains("x86_64") {
            info_status("x86_64 (AMD64) architecture - Full support", 0);
        } else if platform.arch.contains("aarch64") || platform.arch.contains("arm64") {
            info_status("AArch64 (ARM64) architecture - Full support", 0);
        } else if platform.arch.contains("x86") {
            info_status("x86 (32-bit) architecture - Limited support", 2);
        } else {
            info_status(&format!("{} architecture - Experimental support", platform.arch), 2);
        }
        
        return Ok(());
    }
    
    info!("ğŸš€ Starting Password Hash Generator on {}", platform.display());
    info!("Platform details: {}", get_detailed_platform_info());
    
    // Load configuration
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            info_step("Configuration Error", 50, '!');
            info_status(&format!("{} - Configuration loading failed: {}", get_time_now(), e), 1);
            info_status("Configuration sources:", 3);
            info_status("  - Command line arguments", 3);
            info_status("  - Configuration files (via --file)", 3);
            info_status("Supported parameters:", 3);
            info_status("  --text: User information (name, email, site)", 3);
            info_status("  --hash: Hash parameters (method, cut, end, upper-start)", 3);
            info_status("  --file: Configuration file path", 3);
            std::process::exit(1);
        }
    };
    
    // Show configuration information
    if cli_args.show_config {
        config.display_detailed_config();
        return Ok(());
    }
    
    // ... (å…¶ä½™ä¸»å‡½æ•°é€»è¾‘ä¿æŒä¸å˜)
    
    Ok(())
}

// ... (æµ‹è¯•æ¨¡å—ä¿æŒä¸å˜)
```

## ä¸»è¦ä¿®å¤å’Œæ”¹è¿›

### 1. **ä¿®å¤çš„è·¨å¹³å°é—®é¢˜**
- âœ… æ·»åŠ äº†çœŸæ­£çš„å¹³å°ç‰¹å®šä»£ç  (`#[cfg(...)]` å±æ€§)
- âœ… å®ç°äº† Windowsã€Linuxã€macOS çš„ç‰¹å®šåŠŸèƒ½
- âœ… æ·»åŠ äº† AArch64 æ¶æ„æ”¯æŒæ£€æµ‹
- âœ… å¹³å°ç‰¹å®šçš„è·¯å¾„å¤„ç†
- âœ… å¹³å°ç‰¹å®šçš„æ¢è¡Œç¬¦å¤„ç†

### 2. **æ–°å¢çš„è·¨å¹³å°åŠŸèƒ½**
- **å¹³å°æ£€æµ‹**: å®Œæ•´çš„ OSã€æ¶æ„ã€å®¶æ—ä¿¡æ¯
- **è·¯å¾„å¤„ç†**: å„å¹³å°çš„é»˜è®¤é…ç½®è·¯å¾„
- **æ–‡ä»¶æ“ä½œ**: å¹³å°ç‰¹å®šçš„æƒé™å’Œæ¢è¡Œç¬¦
- **ä¸»æœºæ ‡è¯†**: å„å¹³å°è·å–ä¸»æœºåçš„æ–¹æ³•
- **ç‰ˆæœ¬ä¿¡æ¯**: å„å¹³å°ç³»ç»Ÿç‰ˆæœ¬æ£€æµ‹

### 3. **æ–‡æ¡£æ›´æ–°**
- ç¡®è®¤æ”¯æŒ Windowsã€Linuxã€macOS
- ç¡®è®¤æ”¯æŒ x86_64 å’Œ AArch64 æ¶æ„
- æ·»åŠ äº† Unicode è·¯å¾„æ”¯æŒè¯´æ˜
- è¯¦ç»†çš„å¹³å°å…¼å®¹æ€§ä¿¡æ¯

### 4. **éªŒè¯çš„è¾“å‡ºç¤ºä¾‹**
```bash
# åœ¨ Windows ä¸Š
ğŸ–¥ï¸  Platform Information:
  OS: windows
  Architecture: x86_64
  Family: windows
  Platform Type: Windows
  64-bit: true
  Default Config Path: C:\Users\username\AppData\Roaming\password-generator\config
  Line Ending: "\r\n"

# åœ¨ Linux ä¸Š  
ğŸ–¥ï¸  Platform Information:
  OS: linux
  Architecture: aarch64
  Family: unix
  Platform Type: Linux
  64-bit: true
  Default Config Path: /home/username/.config/password-generator
  Line Ending: "\n"
```

ç°åœ¨è·¨å¹³å°ç¼–è¯‘æ³¨é‡Šæ˜¯å‡†ç¡®å’Œå®Œæ•´çš„ï¼