以下是将该Python代码转换为Rust的实现：

```rust
use std::collections::HashMap;
use std::fs;
use std::io::{self, BufRead, Write};
use std::path::Path;
use clap::{Arg, Command};
use regex::Regex;
use sha1::Sha1;
use sha2::{Sha256, Sha512, Digest};

// 计算字符串哈希值
fn get_string_hash(string: &str, hash_name: &str) -> String {
    let hash_name = hash_name.to_uppercase();
    
    match hash_name.as_str() {
        "MD5" => {
            let digest = md5::compute(string.as_bytes());
            format!("{:x}", digest)
        }
        "SHA1" => {
            let mut hasher = Sha1::new();
            hasher.update(string.as_bytes());
            format!("{:x}", hasher.finalize())
        }
        "SHA256" => {
            let mut hasher = Sha256::new();
            hasher.update(string.as_bytes());
            format!("{:x}", hasher.finalize())
        }
        "SHA512" => {
            let mut hasher = Sha512::new();
            hasher.update(string.as_bytes());
            format!("{:x}", hasher.finalize())
        }
        _ => panic!("不支持的哈希算法: {}", hash_name),
    }
}

// 检查value中是否有任意一个元素在check_list中
fn oneof(value: &str, check_list: &[&str]) -> bool {
    if value.is_empty() {
        return false;
    }
    
    let items: Vec<&str> = value.split(',').map(|item| item.trim()).collect();
    
    for item in items {
        if check_list.contains(&item) {
            return true;
        }
    }
    false
}

// 检查value中的所有元素是否都在check_list中
fn everyof(value: &str, check_list: &[&str]) -> bool {
    if value.is_empty() {
        return false;
    }
    
    let items: Vec<&str> = value.split(',').map(|item| item.trim()).collect();
    
    for item in items {
        if !check_list.contains(&item) {
            return false;
        }
    }
    true
}

// 检查字符串是否为空或仅包含空白字符
fn string_is_empty(value: &str) -> bool {
    value.trim().is_empty()
}

// 如果字符串为空则返回默认值
fn string_get(value: &str, default_value: &str) -> String {
    if string_is_empty(value) {
        default_value.to_string()
    } else {
        value.to_string()
    }
}

// 删除多行文本中的空行
fn mlt_del_emptyline(lines: &[String]) -> Vec<String> {
    lines.iter()
        .filter(|line| !line.trim().is_empty())
        .cloned()
        .collect()
}

// 从文件加载多行文本，如果文件不存在则返回默认文本
fn mlt_load_file(loc: &str, default_text: &str) -> Vec<String> {
    if Path::new(loc).exists() {
        if let Ok(file) = fs::File::open(loc) {
            let reader = io::BufReader::new(file);
            reader.lines().filter_map(Result::ok).collect()
        } else {
            vec![]
        }
    } else {
        if default_text.is_empty() {
            vec![]
        } else {
            default_text.lines().map(|s| s.to_string()).collect()
        }
    }
}

// 获取多行文本的最后一行
fn mlt_get_lastline(lines: &[String]) -> String {
    lines.last().cloned().unwrap_or_default()
}

// 从键值对字符串中获取指定键的值
fn slkv_get(value: &str, slkv: &str, case_sensitive: bool) -> String {
    if slkv.is_empty() {
        return String::new();
    }
    
    let pairs: Vec<&str> = slkv.split(',').map(|pair| pair.trim()).collect();
    let search_key = if case_sensitive {
        value.trim().to_string()
    } else {
        value.trim().to_uppercase()
    };
    
    for pair in pairs {
        if pair.contains(':') {
            let parts: Vec<&str> = pair.splitn(2, ':').collect();
            let key = parts[0].trim();
            let val = parts[1].trim();
            
            let compare_key = if case_sensitive {
                key.to_string()
            } else {
                key.to_uppercase()
            };
            
            if compare_key == search_key {
                return val.to_string();
            }
        }
    }
    
    String::new()
}

// 获取分号前的部分
fn sslf_get_head(data: &str) -> String {
    data.split(';').next().unwrap_or(data).to_string()
}

// 获取分号后的部分
fn sslf_get_tail(data: &str) -> String {
    data.split(';').nth(1).unwrap_or("").to_string()
}

// 加载文件并清理注释和空行
fn sslf_load_file(loc: &str, default_text: &str) -> Vec<String> {
    let lines = mlt_load_file(loc, default_text);
    
    // 编译正则表达式
    let comment_re = Regex::new(r"^#.*").unwrap();
    let html_comment_re = Regex::new(r"<!--.*-->").unwrap();
    
    lines.iter()
        .filter_map(|line| {
            // 移除注释行和HTML注释
            let clean_line = comment_re.replace(line, "");
            let clean_line = html_comment_re.replace(&clean_line, "");
            
            if clean_line.trim().is_empty() {
                None
            } else {
                Some(clean_line.to_string())
            }
        })
        .collect()
}

// 从数据中移除name:, email:, site:等前缀
fn shtkv_get_pure_v(data: &str) -> String {
    if data.is_empty() {
        return String::new();
    }
    
    // 编译正则表达式
    let prefix_re = Regex::new(r"(name:|email:|site:)").unwrap();
    let trailing_comma_re = Regex::new(r",$").unwrap();
    
    let cleaned = prefix_re.replace_all(data, "");
    let cleaned = trailing_comma_re.replace(&cleaned, "");
    cleaned.trim().to_string()
}

// 获取路径中的文件名
fn path_get_name(path: &str) -> String {
    Path::new(path)
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("")
        .to_string()
}

// 获取路径中的目录部分
fn path_get_dirs(path: &str) -> String {
    Path::new(path)
        .parent()
        .and_then(|parent| parent.to_str())
        .unwrap_or("")
        .to_string()
}

// 规范化路径分隔符
fn path_normalize(path: &str, search: &str, replace: &str) -> String {
    path.replace(search, replace)
}

// 检查路径是否存在
fn os_path_exist(loc: &str) -> bool {
    Path::new(loc).exists()
}

// 创建目录
fn os_path_make(loc: &str) -> Result<(), std::io::Error> {
    if !loc.is_empty() && !os_path_exist(loc) {
        fs::create_dir_all(loc)
    } else {
        Ok(())
    }
}

// 将密码添加到文件中
fn add_password_to_file(loc: &str, password: &str) -> Result<(), std::io::Error> {
    if os_path_exist(loc) {
        let content = fs::read_to_string(loc)?;
        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
        lines.push(password.to_string());
        
        fs::write(loc, lines.join("\n"))?;
    } else {
        fs::write(loc, password)?;
    }
    
    Ok(())
}

// 用HTML注释包装文本
fn html_comment_wrap(text: &str) -> String {
    format!("<!-- {} -->", text)
}

// 移除HTML注释包装
fn html_comment_unwrap(text: &str) -> String {
    text.trim()
        .trim_start_matches("<!--")
        .trim_end_matches("-->")
        .trim()
        .to_string()
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let matches = Command::new("密码哈希生成器")
        .about("生成密码哈希")
        .arg(Arg::new("cmd")
            .help("命令")
            .index(1)
            .default_value("add"))
        .arg(Arg::new("text")
            .long("text")
            .help("文本参数"))
        .arg(Arg::new("hash")
            .long("hash")
            .help("哈希参数"))
        .arg(Arg::new("slkv")
            .long("slkv")
            .help("字符串键值对"))
        .arg(Arg::new("sslf")
            .long("sslf")
            .help("安全字符串格式"))
        .arg(Arg::new("save")
            .long("save")
            .help("保存文件路径"))
        .arg(Arg::new("file")
            .long("file")
            .help("输入文件路径"))
        .get_matches();

    // 默认的slkv文本
    let default_slkv = "name:yemiancheng,email:yemiancheng1993@163.com,site:www.atyun.com,;method:sha512,cut:8,end:!,upper-start:3";
    
    // 从各种参数获取配置
    let mut slkv_txt = matches.get_one::<String>("text")
        .map(|s| s.as_str())
        .unwrap_or(default_slkv);
    
    slkv_txt = matches.get_one::<String>("hash")
        .map(|s| s.as_str())
        .unwrap_or(slkv_txt);
    
    slkv_txt = matches.get_one::<String>("slkv")
        .map(|s| s.as_str())
        .unwrap_or(slkv_txt);
    
    slkv_txt = matches.get_one::<String>("sslf")
        .map(|s| s.as_str())
        .unwrap_or(slkv_txt);
    
    let mut slkv_txt = slkv_txt.to_string();

    // 从文件获取配置
    if let Some(file_path) = matches.get_one::<String>("file") {
        let config_lines = sslf_load_file(file_path, &slkv_txt);
        let config_last_line = mlt_get_lastline(&config_lines);
        slkv_txt = string_get(&config_last_line, &slkv_txt);
    }

    // 解析配置
    let sslf_head = sslf_get_head(&slkv_txt);
    let sslf_tail = sslf_get_tail(&slkv_txt);
    let sslf_head_pure_v = shtkv_get_pure_v(&sslf_head);

    // 获取哈希参数
    let mut method = slkv_get("method", &sslf_tail, false);
    method = string_get(&method, "SHA512");

    let stringhash_text = string_get(&sslf_head_pure_v, &sslf_head);
    let hash_value = get_string_hash(&stringhash_text, &method);

    // 处理哈希截取
    let mut cut_length = slkv_get("cut", &sslf_tail, false);
    cut_length = string_get(&cut_length, "8");
    let cut_length: usize = cut_length.parse().unwrap_or(8);
    let mut hash_cut = hash_value[..hash_value.len().min(cut_length)].to_string();

    // 处理结束字符
    let mut end_string = slkv_get("end", &sslf_tail, false);
    end_string = string_get(&end_string, "!");
    if !end_string.is_empty() {
        if let Some(end_char) = end_string.chars().next() {
            if !hash_cut.is_empty() {
                hash_cut.pop();
                hash_cut.push(end_char);
            }
        }
    }

    // 处理大写转换
    let mut upper_start = slkv_get("upper-start", &sslf_tail, false);
    upper_start = string_get(&upper_start, "3");
    if !upper_start.is_empty() {
        let upper_start: usize = upper_start.parse().unwrap_or(3);
        if upper_start <= hash_cut.len() {
            let upper_part = hash_cut[..upper_start].to_uppercase();
            let lower_part = &hash_cut[upper_start..];
            hash_cut = format!("{}{}", upper_part, lower_part);
        }
    }

    // 生成结果
    let name = slkv_get("name", &sslf_head, false);
    let site = slkv_get("site", &sslf_head, false);
    let result = format!("{},{},{}", name, hash_cut, site);

    println!("{}", result);

    // 保存结果
    if let Some(save_path) = matches.get_one::<String>("save") {
        let file_path = matches.get_one::<String>("file");
        
        let password_text = if file_path.map(|s| s.as_str()) == Some(save_path) {
            html_comment_wrap(&result)
        } else {
            let result_wrapped = html_comment_wrap(&result);
            format!("{}\n{}", slkv_txt, result_wrapped)
        };

        add_password_to_file(save_path, &password_text)?;
    }

    Ok(())
}
```

需要在 `Cargo.toml` 中添加以下依赖：

```toml
[dependencies]
clap = { version = "4.0", features = ["derive"] }
regex = "1.0"
md5 = "0.7.0"
sha1 = "0.10.0"
sha2 = "0.10.0"
```

这个Rust实现包含了原Python代码的所有功能：

## 主要特性：

1. **哈希计算**：支持MD5、SHA1、SHA256、SHA512算法
2. **字符串处理**：包含各种字符串检查和获取函数
3. **文件操作**：读取、写入、创建目录等功能
4. **配置解析**：从命令行参数和配置文件解析设置
5. **文本处理**：清理注释、处理多行文本等

## 使用方式：

```bash
# 基本使用
cargo run -- add

# 指定文本和保存路径
cargo run -- --text "name:test,site:example.com" --save output.txt

# 从文件读取配置
cargo run -- --file config.txt --save passwords.txt
```

这个实现保持了与原Python代码相同的接口和行为，同时利用了Rust的类型安全和错误处理特性。